/*@ Random number generator.
 *
 * Copyright (c) 2001 - 2021 Steffen (Daode) Nurpmeso <steffen@sdaoden.eu>.
 * SPDX-License-Identifier: ISC
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef su_RANDOM_H
#define su_RANDOM_H

/*!
 * \file
 * \ingroup RANDOM
 * \brief \r{RANDOM}
 */

#include <su/code.h>

#define su_HEADER
#include <su/code-in.h>
C_DECL_BEGIN

struct su_random;

/* random {{{ */
/*!
 * \defgroup RANDOM Random number generator
 * \ingroup MISC
 * \brief Random number generator (\r{su/random.h})
 * @{
 */

/*! \_ */
enum su_random_type{
   /*! No type (value 0); not in practice but if \r{su_random_create()} fails
    * (so \r{su_random_gut()} can do the right thing). */
   su_RANDOM_TYPE_NONE,
   /*! Pseudo random number generator (fast).
    * Permutates itself as it goes, and each output byte is the mixed
    * combination of two (pseudo) random bytes of the seed buffer. */
   su_RANDOM_TYPE_P,
   /*! Strong pseudo (slow).
    * Returns digest(s) of output generated by \c{su_RANDOM_TYPE_P}.
    * Periodically seed can be mixed, adjust \r{su_random::rm_reseed_after}
    * accordingly. */
   su_RANDOM_TYPE_SP,
   /*! Very strong pseudo (even slower).
    * Identical to \c{su_RANDOM_TYPE_SP} by default, except that digest
    * parameters are rised if possible, and periodical mixing of seed is by
    * default enabled.
    * This type can be hooked via \r{su_random_vsp_install()}, for example to
    * make use of OpenSSL's \c{RAND_bytes(3)} function, and therefore
    * potentially yield cryptographically strong pseudo random numbers. */
   su_RANDOM_TYPE_VSP
};

/*! See \r{su_random_vsp_install()} (and \r{su_RANDOM_TYPE_VSP}). */
typedef boole (*su_random_generate_fun)(void **cookie, void *buf, uz len);

/*! \_ */
struct su_random{
   BITENUM_IS(u8,su_random_type) rm_type; /*!< \_ */
   u8 rm_flags;
   u8 rm_ro1;
   u8 rm_ro2;
   /*! For \r{su_RANDOM_TYPE_SP}, and also for \r{su_RANDOM_TYPE_VSP} without
    * \r{su_random_vsp_install()}ation, automatic seed mixing after generating
    * that many random bytes can be performed, setting it to 0 disables
    * automatic seed mixing.
    * By default disabled for the former, and enabled for the latter type. */
   u32 rm_reseed_after;
   u32 rm_bytes;
   su_64( u8 rm__pad[4]; )
   void *rm_vp;
   void *rm_vsp_cookie;
};

/*! Constructor.
 * The object is not seeded, use \r{su_random_seed()} for that.
 * \ESTATE_RV: once the first object is created the internal machinery is
 * initialized, which may fail (but see \r{su_STATE_CREATE_RANDOM})!
 * Dependent upon \a{type} memory allocation may fail for \SELF itself. */
EXPORT s32 su_random_create(struct su_random *self, enum su_random_type type,
      u32 estate);

/*! Destructor (no harm to call if creation of \SELF failed). */
EXPORT void su_random_gut(struct su_random *self);

/*! Seed an object, either by means of the output of a given, or a built-in
 * seeder object.
 * This function may block for some time dependent upon the used seeding (and
 * the state of the seeder object).
 * This function may fail due to a given \a{with_or_nil}, or when seeding
 * \r{su_RANDOM_TYPE_VSP} with a \r{su_random_vsp_install()}ed hook.
 * (The hook is only called if the cookie is not yet set for \SELF, that is to
 * say that a hooked random generator is not assumed to need seeding at all.)
 *
 * The internal built-in seeder uses the algorithm of \r{su_RANDOM_TYPE_VSP},
 * but is seeded via the \r{su_RANDOM_SEED} source chosen at build time. */
EXPORT boole su_random_seed(struct su_random *self,
      struct su_random *with_or_nil);

/*! Generate random bytes.
 * This may fail only for the \r{su_RANDOM_TYPE_VSP} type,
 * and for the reasons shown for \r{su_random_seed()}.
 * This is a no-op if \a{len} is 0. */
EXPORT boole su_random_generate(struct su_random *self, void *buf, uz len);

/*! Install a \r{su_RANDOM_TYPE_VSP} random number generator hook.
 * It will be used by all newly created objects, as long as those exist.
 * If \a{on_generate} is \NIL the default built-in behaviour is
 * (re)established, and be picked up by newly created objects.
 * (If \r{su_RANDOM_SEED} is \c{su_RANDOM_SEED_HOOK} then the default behaviour
 * is redirection through a hook already.)
 * \ESTATE_RV: once the first random object is created the internal machinery
 * is setup, which may fail (but see \r{su_STATE_CREATE_RANDOM}).
 *
 * \a{cookie} of \a{on_generate} is object specific and initially \NIL.
 * For as long as \a{*cookie} is \NIL \r{su_random_seed()} will call the hook
 * with all arguments 0, and only upon r{su_random_gut()} time, when \a{cookie}
 * is not \NIL, will the hook otherwise be called with a \NIL \a{buf} and
 * a length of 0. */
EXPORT s32 su_random_vsp_install(su_random_generate_fun on_generate,
      u32 estate);

/*! Like \r{su_random_generate()}, but uses an internal random number
 * generator of type \r{su_RANDOM_TYPE_SP}.
 * \ESTATE_RV: once the first object is created the internal machinery is
 * setup, which may fail; for this function this is true even for a request
 * \a{len} of 0 (but see \r{su_STATE_CREATE_RANDOM})! */
EXPORT s32 su_random_builtin_generate(void *buf, uz len, u32 estate);
/*! @} *//* }}} */

C_DECL_END
#include <su/code-ou.h>
#if !su_C_LANG || defined CXX_DOXYGEN
# define su_CXX_HEADER
# include <su/code-in.h>
NSPC_BEGIN(su)

class random;

/* random {{{ */
/*!
 * \ingroup RANDOM
 * C++ variant of \r{RANDOM} (\r{su/random.h})
 */
class random : private su_random{
   su_CLASS_NO_COPY(random);
public:
   /*! \copydoc{su_random_type} */
   enum type{
      type_p = su_RANDOM_TYPE_P, /*!< \copydoc{su_RANDOM_TYPE_P} */
      type_sp = su_RANDOM_TYPE_SP, /*!< \copydoc{su_RANDOM_TYPE_SP} */
      type_vsp = su_RANDOM_TYPE_VSP /*!< \copydoc{su_RANDOM_TYPE_VSP} */
   };

   /*! \copydoc{su_random_generate_fun} */
   typedef su_random_generate_fun generate_fun;

   /*! \remarks{Creation may fail: \r{create()} is real constructor!} */
   random(void) {STRUCT_ZERO(su_random, this);}

   /*! \copydoc{su_random_gut()} */
   ~random(void) {su_random_gut(this);}

   /*! \copydoc{su_random_create()} */
   s32 create(type type=type_p, u32 estate=state::none){
      return su_random_create(this, S(enum su_random_type,type), estate);
   }

   /*! \_ */
   type type(void) const {return S(enum type,rm_type);}

   /*! \copydoc{su_random::rm_reseed_after} */
   u32 reseed_after(void) const {return rm_reseed_after;}

   /*! \copydoc{su_random::rm_reseed_after} */
   random &set_reseed_after(u32 count){
      ASSERT_RET(type() == type_sp || type() == type_vsp, *this);
      rm_reseed_after = count;
      return *this;
   }

   /*! \copydoc{su_random_seed()} */
   boole seed(void) {return su_random_seed(this, NIL);}
   /*! \copydoc{su_random_seed()} */
   boole seed(random &with) {return su_random_seed(this, &with);}

   /*! \copydoc{su_random_generate()} */
   boole generate(void *buf, uz len){
      ASSERT_RET(buf != NIL || len == 0, FAL0);
      return su_random_generate(this, buf, len);
   }

   /*! \copydoc{su_random_generate()} */
   boole operator()(void *buf, uz len) {return generate(buf, len);}

   /*! \copydoc{su_random_vsp_install()} */
   static s32 vsp_install(generate_fun on_generate, u32 estate=state::none){
      return su_random_vsp_install(on_generate, estate);
   }

   /*! \copydoc{su_random_builtin_generate()} */
   static s32 builtin_generate(void *buf, uz len, u32 estate=state::none){
      ASSERT_RET(buf != NIL || len == 0, -err::efault);
      return su_random_builtin_generate(buf, len, estate);
   }
};
/* }}} */

NSPC_END(su)
# include <su/code-ou.h>
#endif /* !C_LANG || @CXX_DOXYGEN */
#endif /* su_RANDOM_H */
/* s-it-mode */
